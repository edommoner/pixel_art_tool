import JSZip from "jszip";
import { saveAs } from "file-saver";
function makeOutCanvas(w, h) {
  const c = document.createElement("canvas");
  return ((c.width = w), (c.height = h), c);
}
export async function exportLayersAsZip(state, baseCanvas) {
  const base = baseCanvas,
    bw = base.width,
    bh = base.height,
    bctx = base.getContext("2d", { willReadFrequently: !0 }),
    bimg = bctx.getImageData(0, 0, bw, bh),
    palette =
      state.paletteSnapshot && state.paletteSnapshot.length
        ? state.paletteSnapshot
        : state.activePalette;
  if (!palette || !palette.length)
    throw new Error("Palette is empty. Run quantization first.");
  const scale = state.layerScale || 1,
    outW = bw * scale,
    outH = bh * scale,
    zip = new JSZip(),
    hits = Array.from({ length: palette.length }, () => []),
    data = bimg.data;
  for (let y = 0; y < bh; y++) {
    const row = y * bw * 4;
    for (let x = 0; x < bw; x++) {
      const i = row + 4 * x,
        r = data[i],
        g = data[i + 1],
        b = data[i + 2];
      let idx = -1;
      for (let p = 0; p < palette.length; p++) {
        const pp = palette[p];
        if (pp[0] === r && pp[1] === g && pp[2] === b) {
          idx = p;
          break;
        }
      }
      idx >= 0 && hits[idx].push([x, y]);
    }
  }
  for (let pi = 0; pi < palette.length; pi++) {
    const pts = hits[pi];
    if (!pts.length) continue;
    const oc = makeOutCanvas(outW, outH),
      octx = oc.getContext("2d");
    ((octx.imageSmoothingEnabled = !1),
      octx.clearRect(0, 0, outW, outH),
      (octx.fillStyle = `rgb(${palette[pi][0]},${palette[pi][1]},${palette[pi][2]})`));
    const s = 0 | scale;
    for (let k = 0; k < pts.length; k++) {
      const x = pts[k][0] * s,
        y = pts[k][1] * s;
      octx.fillRect(0 | x, 0 | y, s, s);
    }
    const dataUrl = oc.toDataURL("image/png"),
      base64 = dataUrl.split(",")[1],
      blockId = palette[pi][3] || "block",
      name = `${String(pi).padStart(2, "0")}_${blockId}.png`;
    zip.file(name, base64, { base64: !0 });
  }
  const blob = await zip.generateAsync({ type: "blob" }),
    zipName = (state.exportName || "layers") + ".zip";
  saveAs(blob, zipName);
}
