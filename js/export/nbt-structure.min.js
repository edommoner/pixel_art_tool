import { els } from "../ui/elements.js";
import { DATA_VERSION } from "../constants.js";
import { saveAs } from "file-saver";
import { gzip } from "pako";
import { NbtWriterJE } from "../nbt/writer.js";
class NbtWriter {
  constructor() {
    this.chunks = [];
  }
  toGzipBuffer(rootName, rootCompound) {
    const raw = this._writeNamedCompound(rootName, rootCompound);
    return gzip(raw);
  }
  _append(dst, src) {
    for (let i = 0; i < src.length; i++) dst.push(src[i]);
  }
  _writeNamedCompound(name, value) {
    const w = [];
    return (
      this._append(w, this._u8(10)),
      this._append(w, this._str(name)),
      this._append(w, this._compoundBody(value)),
      w.push(0),
      new Uint8Array(w)
    );
  }
  _compoundBody(obj) {
    const out = [];
    for (const [k, v] of Object.entries(obj))
      if (null != v)
        if ("number" == typeof v)
          (this._append(out, this._u8(3)),
            this._append(out, this._str(k)),
            this._append(out, this._i32(v)));
        else if ("string" == typeof v)
          (this._append(out, this._u8(8)),
            this._append(out, this._str(k)),
            this._append(out, this._str(v)));
        else if (Array.isArray(v) && v.every((n) => Number.isInteger(n))) {
          (this._append(out, this._u8(9)),
            this._append(out, this._str(k)),
            this._append(out, this._u8(3)),
            this._append(out, this._i32(v.length)));
          for (const n of v) this._append(out, this._i32(n));
        } else if (Array.isArray(v)) {
          (this._append(out, this._u8(9)),
            this._append(out, this._str(k)),
            this._append(out, this._u8(10)),
            this._append(out, this._i32(v.length)));
          for (const c of v)
            (this._append(out, this._compoundBody(c)), out.push(0));
        } else
          "object" == typeof v &&
            (this._append(out, this._u8(10)),
            this._append(out, this._str(k)),
            this._append(out, this._compoundBody(v)),
            out.push(0));
    return out;
  }
  _u8(n) {
    return [255 & n];
  }
  _i16(n) {
    const b = new Uint8Array(2);
    return (new DataView(b.buffer).setInt16(0, n, !1), [...b]);
  }
  _i32(n) {
    const b = new Uint8Array(4);
    return (new DataView(b.buffer).setInt32(0, n, !1), [...b]);
  }
  _str(s) {
    const enc = new TextEncoder(),
      u8 = enc.encode(s),
      out = this._i16(u8.length);
    for (let i = 0; i < u8.length; i++) out.push(u8[i]);
    return out;
  }
}
function paletteFromState(state) {
  return state.activePalette.map((p) => {
    const name = p[3];
    return { Name: name };
  });
}
function sizeFromCanvas(canvas) {
  return [canvas.width, 1, canvas.height];
}
function blocksFromImage(canvas, state) {
  const sizeX = canvas.width,
    sizeZ = canvas.height,
    ctx = canvas.getContext("2d"),
    data = ctx.getImageData(0, 0, sizeX, sizeZ).data,
    keyToIndex = new Map();
  state.activePalette.forEach((p, i) => {
    keyToIndex.set(`${p[0]},${p[1]},${p[2]}`, i);
  });
  const blocks = [];
  for (let z = 0; z < sizeZ; z++)
    for (let x = 0; x < sizeX; x++) {
      const idx = 4 * (z * sizeX + x),
        key = `${data[idx]},${data[idx + 1]},${data[idx + 2]}`,
        stateIndex = keyToIndex.get(key);
      void 0 !== stateIndex &&
        blocks.push({ state: stateIndex, pos: [x, 0, z] });
    }
  return blocks;
}
export function exportStructureNbt(state) {
  const canvas = els.resultCanvas;
  if (!canvas || 0 === canvas.width)
    return void alert("先に画像を変換してください。");
  const struct = {
      DataVersion: DATA_VERSION,
      size: sizeFromCanvas(canvas),
      palette: paletteFromState(state),
      blocks: blocksFromImage(canvas, state),
      entities: [],
    },
    writer = new NbtWriterJE(),
    raw = writer.writeNamedCompound("", struct),
    gz = gzip(raw),
    blob = new Blob([gz], { type: "application/octet-stream" }),
    w = canvas.width,
    h = canvas.height;
  saveAs(blob, `mapart_${w}x${h}.nbt`);
}
